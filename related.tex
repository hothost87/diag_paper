\section{Related Work}
\label{related}

To the best of our knowledge, we present the first work that focuses on automating the process of localizing the root causes when a JavaScript static analysis produces impractical results on a program. Nevertheless, our work is related to (i) recent static context-sensitive analyses that unveiled difficult JavaScript program constructs, and (ii) static analysis that identifies the causes of precision loss for refinement.

\subsection{JavaScript Context-sensitive Analysis}

Sridharan et al. identify correlated dynamic property accesses (e.g., {\tt x[p] = y[p]}) as a hard-to-analyze JavaScript code pattern and present a specialized argument-sensitive analysis along with program transformation that dramatically improves analysis scalability and precision on JavaScript libraries \cite{Sridharan:2012:CTP:2367163.2367191}. This work motivated us to design an automatic localization algorithm that identifies such program constructs causing the analysis imprecision. We also have reused the library benchmarks collected by Sridharan et al. \cite{Sridharan:2012:CTP:2367163.2367191} as Benchmarks I in the evaluation.

Esben et al. infer determinacy information (i.e., a variable and expression always has the same value at a given program point \cite{Schafer:2013:DDA:2491956.2462168}) and improve static analysis precision on JavaScript libraries via various techniques \cite{Andreasen:2014:DSA:2660193.2660214}. For example, argument sensitivity is selectively applied for the arguments whose abstract value is a concrete string or a single object address. This specialized context sensitivity is proposed as a result of manually inspecting imprecise portions of an incomplete call graph obtained after a fixed number of evaluations. In our work, root causes of the analysis imprecision are automatically localized and a user is provided with focused program constructs for inspection.

Wei and Ryder present a two-staged context-sensitive analysis for JavaScript that selectively applies specific context sensitivity on the function level \cite{DBLP:conf/ecoop/WeiR15}. Heuristics are used to decide the context sensitivity based on the function characteristics extracted from the results of a pre-analysis. Our improvement suggestion may also result in applying different context sensitivity on the root cause functions. However, our approach does not require a pre-analysis that finishes analyzing the target program and our goal is to apply the specialized context sensitivity only on the root cause functions that may significantly improve the overall analysis scalability and precision.

Park and Ryu present another static analysis of JavaScript that improves precision via loop sensitivity \cite{DBLP:conf/ecoop/ParkR15}. The authors identify one root cause of scalability problems with JavaScript analysis as the combination of imprecise results in loops and in dynamic property accesses. Their analysis improves precision in loops by distinguishing each iteration of a loop with different contexts based on the analysis results of loop conditional expressions. Our approach systematically assists in the process of locating such code patterns as root causes of analysis scalability problems.

%Kashyap et al. present {\it JSAI}, an abstract interpreter for JavaScript and evaluate the analysis precision and performance on JavaScript benchmarks with different context-sensitive analyses \cite{Kashyap:2014:JSA:2635868.2635904}. We used a subset of the JavaScript benchmarks as Benchmarks II in our evaluation.

\subsection{Refinement-based Analysis}

Smaragdakis et al. present introspective analysis that aims to improve the performance of a context-sensitive analysis for Java \cite{Smaragdakis:2014:IAC:2594291.2594320}. Introspective analysis uses heuristics to decide whether to refine an allocation site or a call site with context sensitivity, based on the metrics computed from context-insensitive points-to results. The heuristics focus on reasoning about the cost of applying additional context sensitivity. Instead, we focus on identifying the constructs that originate significant loss of performance and/or precision of an analysis; therefore, applying more accurate but expensive analysis techniques only on these constructs may result in the improvement of the overall analysis performance and precision.

Sridharan and Bod\'{\i}k present a refinement-based points-to analysis for Java that refines sensitivity for heap accesses and method calls \cite{Sridharan:2006:RCP:1133981.1134027}. The analysis is demand-driven and client-driven in that it focuses on refining the analysis of relevant code. We focus on improving the overall points-to analysis precision in terms of all possible queries for points-to sets of program variables, instead of precisely answering a specific query.

Guyer and Lin present a client-driven analysis for C that automatically adjusts its precision in response to the needs of client analyses \cite{Guyer:2003:CPA:1760267.1760284}. This client-driven analysis monitors polluting assignments (i.e., the program points that result inaccuracy in the analysis) and tunes context as well as flow sensitivity to improve precision. Our heuristics to locate the root causes consider not only the inaccurate results at a program point but also its impact on the overall points-to analysis precision by tracking the labels in the propagation system. 